from django.db import models


class Ageclass(models.Model):
    """Ages, can include Infant, Juvenile, Adult, Unknown."""

    name = models.CharField("Age class", max_length=50)
    abbr = models.CharField("Abbreviation", max_length=50)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "age_class"
        verbose_name_plural = "age classes"


""" All auth models are generated by Django. """


class AuthGroup(models.Model):
    name = models.CharField(max_length=80, unique=True)
    description = models.CharField(max_length=80, null=True)

    class Meta:
        managed = False
        db_table = "auth_group"


class AuthPermission(models.Model):
    name = models.CharField(max_length=255)
    content_type = models.ForeignKey("DjangoContentType", on_delete=models.PROTECT)
    codename = models.CharField(max_length=100)

    class Meta:
        managed = False
        db_table = "auth_permission"
        unique_together = (("content_type", "codename"),)


class AuthGroupPermissions(models.Model):
    group = models.ForeignKey(AuthGroup, on_delete=models.PROTECT)
    permission = models.ForeignKey(AuthPermission, on_delete=models.PROTECT)

    class Meta:
        managed = False


#         db_table = 'auth_group_permissions'
#         # unique_together = (('group', 'permission'),)


class AuthUser(models.Model):
    password = models.CharField(max_length=128)
    last_login = models.DateTimeField(blank=True, null=True)
    is_superuser = models.IntegerField()
    username = models.CharField(max_length=30, unique=True)
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
    email = models.CharField(max_length=254)
    is_staff = models.IntegerField()
    is_active = models.IntegerField()
    date_joined = models.DateTimeField()

    class Meta:
        managed = False
        db_table = "auth_user"


class AuthUserGroups(models.Model):
    user = models.ForeignKey(AuthUser, on_delete=models.PROTECT)
    group = models.ForeignKey(AuthGroup, on_delete=models.PROTECT)

    class Meta:
        managed = False
        # db_table = 'auth_user_groups'
        unique_together = (("user", "group"),)


""" End of auth models generated by Django. """

# class AuthUserUserPermissions(models.Model):
#     user       = models.ForeignKey(AuthUser,       on_delete=models.PROTECT)
#     # permission = models.ForeignKey(AuthPermission, on_delete=models.PROTECT)

#     class Meta:
#         managed         = True
#         # db_table        = 'auth_user_user_permissions'
#         # unique_together = (('user', 'permission'),)


class Bodypart(models.Model):
    """
    Bodyparts, including information on where it fits in the tree
    generated in the front end by nlstree.
    """

    name = models.CharField("Bodypart name", max_length=191, unique=True)
    parent = models.ForeignKey(
        "Bodypart",
        null=True,
        on_delete=models.PROTECT,
        verbose_name="Parent Bodypart",
    )
    expand_in_tree = models.BooleanField(blank=False, null=False, default=False)
    tree_root = models.BooleanField(blank=False, null=False, default=False)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "bodypart"
        ordering = ["id"]


class BodypartVariable(models.Model):
    """Lookup table for which bodypart a given variable belongs to."""

    variable = models.ForeignKey("Variable", on_delete=models.PROTECT)
    bodypart = models.ForeignKey("Bodypart", on_delete=models.PROTECT)

    class Meta:
        managed = True
        db_table = "bodypart_variable"
        verbose_name = "Bodypart-variable link"
        ordering = ["id"]


class Captive(models.Model):
    """Whether the specimen was wild-caught or captive."""

    CHOICES = (
        ("captive", "captive"),
        ("wild-caught", "wild-caught"),
        ("probably captive", "probably captive"),
        ("unknown", "unknown"),
    )
    name = models.CharField(
        "Captive or wild-caught",
        max_length=16,
        blank=True,
        choices=CHOICES,
    )
    abbr = models.CharField("Abbreviation", max_length=2, blank=True, null=True)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "captive"
        verbose_name_plural = "captive"
        ordering = ["id"]


class Continent(models.Model):
    """A list of the continents"""

    CHOICES = (
        ("Africa", "Africa"),
        ("Asia", "Asia"),
        ("Europe", "Europe"),
        ("Australia", "Australia"),
        ("North America", "North America"),
        ("South America", "South America"),
        ("Unknown", "Unknown"),
    )
    name = models.CharField(
        "Continent name", max_length=32, blank=True, unique=True, choices=CHOICES
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "continent"


class Country(models.Model):
    """A list of possible countries."""

    name = models.CharField(
        "Country name",
        max_length=191,
        blank=False,
        null=False,
        unique=False,
        default=10000,
    )
    abbr = models.CharField(
        "Abbreviation", max_length=8, blank=True, null=True, unique=True
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "country"
        verbose_name_plural = "countries"
        ordering = ["name"]


class Data3D(models.Model):
    """Point data for three-dimensional model points in space."""

    session = models.ForeignKey("Session", on_delete=models.PROTECT)
    variable = models.ForeignKey("Variable", on_delete=models.PROTECT)
    datindex = models.IntegerField(blank=True, null=True)
    x = models.DecimalField(
        blank=True,  # Decimals because we're checking
        null=True,  # against strings with four
        decimal_places=4,  # digits: "9999.0000".
        max_digits=8,  # Actually less important,
        default=9999.0000,  # we're storing to four
    )  # decimal places.
    y = models.DecimalField(
        blank=True,
        null=True,
        decimal_places=4,
        max_digits=8,
        default=9999.0000,
    )
    z = models.DecimalField(
        blank=True,
        null=True,
        decimal_places=4,
        max_digits=8,
        default=9999.0000,
    )

    class Meta:
        managed = True
        db_table = "data_3d"
        verbose_name = "3D data"
        verbose_name_plural = "3D data"


class DataScalar(models.Model):
    """Scalar data for a given session and variable."""

    session = models.ForeignKey("Session", on_delete=models.PROTECT)
    variable = models.ForeignKey("Variable", on_delete=models.PROTECT)
    value = models.CharField(max_length=10, blank=True, null=True)

    class Meta:
        managed = True
        db_table = "data_scalar"
        verbose_name = "scalar data"
        verbose_name_plural = "scalar data"
        ordering = ["id"]


class Datatype(models.Model):
    """Whether it's scalar, 3D or from an external data source."""

    TYPES = (
        ("scalar", "scalar"),
        ("data3d", "3D data"),
        ("external", "external"),
    )
    label = models.CharField(max_length=255, blank=True, null=True)
    data_table = models.CharField(
        "Data type",
        max_length=32,
        blank=True,
        choices=TYPES,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.data_table

    class Meta:
        managed = True
        db_table = "datatype"
        ordering = ["id"]


class Device(models.Model):
    """The device used to capture 3D points."""

    name = models.CharField(max_length=255)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "device"


class DjangoAdminLog(models.Model):
    """Set by Django."""

    action_time = models.DateTimeField()
    object_id = models.TextField(blank=True, null=True)
    object_repr = models.CharField(max_length=200)
    action_flag = models.SmallIntegerField()
    change_message = models.TextField()
    content_type = models.ForeignKey(
        "DjangoContentType",
        blank=True,
        null=True,
        on_delete=models.PROTECT,
    )
    user = models.ForeignKey(
        AuthUser,
        on_delete=models.PROTECT,
    )

    class Meta:
        managed = False
        db_table = "django_admin_log"


class DjangoContentType(models.Model):
    """Set by Django."""

    app_label = models.CharField(max_length=100)
    model = models.CharField(max_length=100)

    class Meta:
        managed = False
        db_table = "django_content_type"
        unique_together = (("app_label", "model"),)


class DjangoMigrations(models.Model):
    app = models.CharField(max_length=255)
    name = models.CharField(max_length=255)
    applied = models.DateTimeField()

    class Meta:
        managed = True
        db_table = "django_migrations"


class DjangoSession(models.Model):
    session_key = models.CharField(primary_key=True, max_length=40)
    session_data = models.TextField()
    expire_date = models.DateTimeField()

    class Meta:
        managed = False
        db_table = "django_session"


class Fossil(models.Model):
    """Type of specimen, fossil or not, including abbreviation."""

    name = models.CharField(
        "Fossil or Extant",
        max_length=16,
    )
    abbr = models.CharField(
        "Abbreviation",
        max_length=2,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "fossil"
        ordering = ["id"]
        verbose_name = "Fossil or Extant"
        verbose_name_plural = "Fossil or Extant"


class Institute(models.Model):
    """Research institution with locality as foreign key."""

    abbr = models.CharField(
        "Abbreviation",
        max_length=8,
        blank=True,
        null=True,
    )
    name = models.CharField(
        "Institute",
        max_length=255,
        blank=False,
        null=False,
    )
    institute_department = models.CharField(
        "Department",
        max_length=255,
        blank=True,
        null=True,
    )
    locality = models.ForeignKey(
        "Locality",
        on_delete=models.SET_DEFAULT,
        blank=False,
        null=False,
        default=10000,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "institute"
        ordering = ["name"]


class Laterality(models.Model):
    """Whether two 3D points are lateral, and which kind of laterality."""

    CHOICES = (
        ("none", "none"),
        ("transverse", "transverse"),
        ("median", "median"),
        ("right", "right"),
        ("left", "left"),
        ("unknown", "unknown"),
    )
    name = models.CharField(
        max_length=255,
        choices=CHOICES,
    )
    abbr = models.CharField(
        "Abbreviation",
        max_length=1,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "laterality"
        verbose_name_plural = "laterality"


class Locality(models.Model):
    """
    A locality is a small region marked by a latitude and longitude.
    Foreign keys: country and continent.
    """

    name = models.CharField(
        "Locality",
        max_length=191,
    )
    continent = models.ForeignKey("Continent", default=7, on_delete=models.SET_DEFAULT)
    country = models.ForeignKey("Country", default=10000, on_delete=models.SET_DEFAULT)
    latitude = models.FloatField(blank=True, null=True)
    longitude = models.FloatField(blank=True, null=True)
    site_unit = models.CharField(max_length=255, blank=True, null=True)
    plus_minus = models.FloatField(blank=True, null=True)
    age = models.FloatField(blank=True, null=True)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "locality"
        verbose_name_plural = "localities"


class Observer(models.Model):
    """Name of researcher who did measurement."""

    name = models.CharField(
        max_length=191,
        unique=True,
    )
    initials = models.CharField(
        max_length=4,
        blank=True,
        null=True,
        unique=True,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "observer"
        ordering = ["id"]


class Original(models.Model):
    """Whether a specimen is a cast or an original."""

    CHOICES = (
        ("original", "original"),
        ("cast", "cast"),
    )
    name = models.CharField(
        "Type",
        max_length=16,
        choices=CHOICES,
    )
    abbr = models.CharField(
        "Abbreviation",
        max_length=2,
        blank=True,
        null=True,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "original"
        ordering = ["id"]


class Paired(models.Model):
    """Whether a 3D point is paired with another point."""

    CHOICES = (
        ("Paired", "Paired"),
        ("Unpaired", "Unpaired"),
    )
    name = models.CharField(
        "Type",
        max_length=64,
        choices=CHOICES,
    )
    abbr = models.CharField(
        "Abbreviation",
        max_length=1,
        blank=True,
        null=True,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "paired"
        verbose_name_plural = "paired"


class ProtocolVariable(models.Model):
    """Cross table for protocols and variables. Many-to-many."""

    protocol = models.ForeignKey("Protocol", on_delete=models.CASCADE)
    variable = models.ForeignKey("Variable", on_delete=models.CASCADE)

    class Meta:
        managed = True
        db_table = "protocol_variable"
        verbose_name = "Protocol-variable link"
        ordering = ["id"]


class Protocol(models.Model):
    label = models.CharField("Protocol label", max_length=255, blank=True)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.label

    class Meta:
        managed = True
        db_table = "protocol"
        ordering = ["id"]


# class QueryWizard(models.Model):
#     query_name = models.CharField(max_length=100, blank=True, null=True)
#     query_friendly_name = models.CharField(max_length=255, blank=True, null=True)
#     query_description = models.TextField(blank=True, null=True)

#     class Meta:
#         managed = True
#         db_table = 'query_wizard'


class QueryWizardQuery(models.Model):
    data_table = models.CharField(max_length=20, blank=True, null=True)
    query = models.TextField(blank=True, null=True)
    query_suffix = models.TextField(blank=True, null=True)

    class Meta:
        managed = True
        db_table = "query_wizard_query"


class QueryWizardTable(models.Model):
    """
    A list of tables that will be used during query setup parameter selection.
    """

    query_wizard_query = models.ForeignKey(
        "QueryWizardQuery",
        related_name="tables",
        on_delete=models.PROTECT,
    )
    # How the name of the table will be displayed.
    display_name = models.CharField(max_length=100, blank=True, null=True)
    # When we're filtering by table name, what string to use.
    filter_table_name = models.CharField(max_length=50, blank=True, null=True)
    # Which order to display the tables in.
    display_order = models.IntegerField(blank=True, null=True)
    # If all values from a table (e.g. fossil, sex) will be pre-selected when
    # calling parameter selection, this is True.
    preselected = models.BooleanField(blank=False, null=False, default=False)

    class Meta:
        managed = True
        db_table = "query_wizard_table"


class Rank(models.Model):
    name = models.CharField("Rank name", max_length=255, blank=True)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "rank"
        ordering = ["id"]


class Session(models.Model):
    observer = models.ForeignKey("Observer", on_delete=models.PROTECT)
    specimen = models.ForeignKey("Specimen", on_delete=models.PROTECT)
    protocol = models.ForeignKey("Protocol", on_delete=models.PROTECT)
    original = models.ForeignKey(
        "Original",
        on_delete=models.PROTECT,
        verbose_name="Original or Cast",
    )
    iteration = models.IntegerField(blank=True, null=True)
    comments = models.TextField(blank=True, null=True)
    filename = models.CharField(max_length=255, blank=True, null=True)
    group = models.ForeignKey("AuthGroup", default=3, on_delete=models.PROTECT)

    def __str__(self) -> str:
        return str(self.id)

    class Meta:
        managed = True
        db_table = "session"
        ordering = ["id"]


class Sex(models.Model):
    CHOICES = (
        ("male", "male"),
        ("female", "female"),
        ("male?", "male?"),
        ("female?", "female?"),
        ("possibly male", "possibly male"),
        ("possibly female", "possibly female"),
        ("unknown", "unknown"),
    )
    name = models.CharField(
        "Sex",
        max_length=16,
        choices=CHOICES,
    )
    abbr = models.CharField(
        "Abbreviation",
        max_length=2,
        blank=True,
        null=True,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "sex"
        verbose_name_plural = "sexes"
        ordering = ["id"]


class Taxon(models.Model):
    parent = models.ForeignKey(
        "Taxon",
        on_delete=models.PROTECT,
        null=False,
        verbose_name="Parent Taxon",
    )
    rank = models.ForeignKey(Rank, on_delete=models.PROTECT)
    name = models.CharField(
        "Taxon name",
        max_length=255,
        blank=True,
        null=False,
    )
    fossil = models.ForeignKey(Fossil, on_delete=models.PROTECT)
    expand_in_tree = models.BooleanField(blank=False, null=False, default=False)
    tree_root = models.BooleanField(blank=False, null=False, default=False)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "taxon"
        verbose_name_plural = "taxa"
        ordering = ["name"]


class SpecimenType(models.Model):
    CHOICES = (
        ("holotype", "holotype"),
        ("lectotype", "lectotype"),
        ("syntype", "syntype"),
        ("neotype", "neotype"),
        ("future neotype", "future neotype"),
        ("future neotype", "future neotype"),
        ("unknown", "unknown"),
    )
    name = models.CharField("Name", max_length=16)
    abbr = models.CharField("Abbreviation", max_length=2, blank=True, null=True)
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "specimen_type"
        ordering = ["id"]
        verbose_name = "specimen type"


class Variable(models.Model):
    """
    Label for a group of measurements; which measurements exist on a
    given item.
    Foreign keys: datatype (scalar or 3D)
                  variable, which other variables it is paired with.
    """

    label = models.CharField(
        max_length=32, blank=True, null=True
    )  # this is the id, set by biologists
    name = models.CharField(max_length=255)
    laterality = models.ForeignKey(
        Laterality,
        null=True,
        on_delete=models.PROTECT,
    )
    datatype = models.ForeignKey(Datatype, on_delete=models.PROTECT)
    paired_with = models.ForeignKey(
        "Variable",
        null=True,
        on_delete=models.PROTECT,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name

    class Meta:
        managed = True
        db_table = "variable"


class Specimen(models.Model):
    """
    Data for a given specimen, including where it originated, its
    institute and catalog number, mass, sex, age, comments, etc.
    Foreign keys: taxon
                  institute
                  locality
                  sex
                  age_class
                  fossil
                  captive
                  specimen type
    """

    hypocode = models.CharField(max_length=20, blank=True)
    taxon = models.ForeignKey(Taxon, on_delete=models.PROTECT)
    institute = models.ForeignKey(
        Institute,
        on_delete=models.PROTECT,
        blank=False,
        null=False,
        default=10000,
    )
    catalog_number = models.CharField(
        max_length=64,
        blank=True,
        null=True,
    )
    mass = models.IntegerField(
        blank=False,
        null=False,
        default=0,
    )
    locality = models.ForeignKey(
        Locality,
        on_delete=models.SET_DEFAULT,
        blank=False,
        null=False,
        default=10000,
    )
    sex = models.ForeignKey(
        Sex,
        on_delete=models.PROTECT,
        blank=False,
        null=False,
        default=9,
    )
    age_class = models.ForeignKey(
        Ageclass,
        on_delete=models.PROTECT,
        blank=False,
        null=False,
        default=9,
    )
    fossil = models.ForeignKey(
        Fossil,
        on_delete=models.PROTECT,
        blank=False,
        null=False,
        default=9,
    )
    captive = models.ForeignKey(
        Captive,
        on_delete=models.PROTECT,
        blank=False,
        null=False,
        default=9,
    )
    specimen_type = models.ForeignKey(
        SpecimenType,
        on_delete=models.PROTECT,
        blank=False,
        null=False,
        default=7,
    )
    comments = models.TextField(blank=True, null=True)

    def __str__(self) -> str:
        return self.hypocode

    class Meta:
        managed = True
        db_table = "specimen"
        ordering = ["id"]
